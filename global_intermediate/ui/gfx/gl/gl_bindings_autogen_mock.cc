// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is automatically generated.

#include <string.h>

#include "ui/gfx/gl/gl_interface.h"

namespace gfx {

void GL_BINDING_CALL Mock_glActiveTexture(GLenum texture) {
  GLInterface::GetGLInterface()->ActiveTexture(texture);
}

void GL_BINDING_CALL Mock_glAttachShader(GLuint program, GLuint shader) {
  GLInterface::GetGLInterface()->AttachShader(program, shader);
}

void GL_BINDING_CALL Mock_glBindAttribLocation(GLuint program, GLuint index, const char* name) {
  GLInterface::GetGLInterface()->BindAttribLocation(program, index, name);
}

void GL_BINDING_CALL Mock_glBindBuffer(GLenum target, GLuint buffer) {
  GLInterface::GetGLInterface()->BindBuffer(target, buffer);
}

void GL_BINDING_CALL Mock_glBindFragDataLocation(GLuint program, GLuint colorNumber, const char* name) {
  GLInterface::GetGLInterface()->BindFragDataLocation(program, colorNumber, name);
}

void GL_BINDING_CALL Mock_glBindFragDataLocationIndexedARB(GLuint program, GLuint colorNumber, GLuint index, const char* name) {
  GLInterface::GetGLInterface()->BindFragDataLocationIndexedARB(program, colorNumber, index, name);
}

void GL_BINDING_CALL Mock_glBindFramebufferEXT(GLenum target, GLuint framebuffer) {
  GLInterface::GetGLInterface()->BindFramebufferEXT(target, framebuffer);
}

void GL_BINDING_CALL Mock_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer) {
  GLInterface::GetGLInterface()->BindRenderbufferEXT(target, renderbuffer);
}

void GL_BINDING_CALL Mock_glBindTexture(GLenum target, GLuint texture) {
  GLInterface::GetGLInterface()->BindTexture(target, texture);
}

void GL_BINDING_CALL Mock_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
  GLInterface::GetGLInterface()->BlendColor(red, green, blue, alpha);
}

void GL_BINDING_CALL Mock_glBlendEquation( GLenum mode ) {
  GLInterface::GetGLInterface()->BlendEquation( mode );
}

void GL_BINDING_CALL Mock_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) {
  GLInterface::GetGLInterface()->BlendEquationSeparate(modeRGB, modeAlpha);
}

void GL_BINDING_CALL Mock_glBlendFunc(GLenum sfactor, GLenum dfactor) {
  GLInterface::GetGLInterface()->BlendFunc(sfactor, dfactor);
}

void GL_BINDING_CALL Mock_glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
  GLInterface::GetGLInterface()->BlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
}

void GL_BINDING_CALL Mock_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
  GLInterface::GetGLInterface()->BlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

void GL_BINDING_CALL Mock_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
  GLInterface::GetGLInterface()->BlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

void GL_BINDING_CALL Mock_glBufferData(GLenum target, GLsizei size, const void* data, GLenum usage) {
  GLInterface::GetGLInterface()->BufferData(target, size, data, usage);
}

void GL_BINDING_CALL Mock_glBufferSubData(GLenum target, GLint offset, GLsizei size, const void* data) {
  GLInterface::GetGLInterface()->BufferSubData(target, offset, size, data);
}

GLenum GL_BINDING_CALL Mock_glCheckFramebufferStatusEXT(GLenum target) {
  return GLInterface::GetGLInterface()->CheckFramebufferStatusEXT(target);
}

void GL_BINDING_CALL Mock_glClear(GLbitfield mask) {
  GLInterface::GetGLInterface()->Clear(mask);
}

void GL_BINDING_CALL Mock_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
  GLInterface::GetGLInterface()->ClearColor(red, green, blue, alpha);
}

void GL_BINDING_CALL Mock_glClearDepth(GLclampd depth) {
  GLInterface::GetGLInterface()->ClearDepth(depth);
}

void GL_BINDING_CALL Mock_glClearDepthf(GLclampf depth) {
  GLInterface::GetGLInterface()->ClearDepthf(depth);
}

void GL_BINDING_CALL Mock_glClearStencil(GLint s) {
  GLInterface::GetGLInterface()->ClearStencil(s);
}

void GL_BINDING_CALL Mock_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
  GLInterface::GetGLInterface()->ColorMask(red, green, blue, alpha);
}

void GL_BINDING_CALL Mock_glCompileShader(GLuint shader) {
  GLInterface::GetGLInterface()->CompileShader(shader);
}

void GL_BINDING_CALL Mock_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data) {
  GLInterface::GetGLInterface()->CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}

void GL_BINDING_CALL Mock_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data) {
  GLInterface::GetGLInterface()->CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

void GL_BINDING_CALL Mock_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
  GLInterface::GetGLInterface()->CopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

void GL_BINDING_CALL Mock_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
  GLInterface::GetGLInterface()->CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

GLuint GL_BINDING_CALL Mock_glCreateProgram(void) {
  return GLInterface::GetGLInterface()->CreateProgram();
}

GLuint GL_BINDING_CALL Mock_glCreateShader(GLenum type) {
  return GLInterface::GetGLInterface()->CreateShader(type);
}

void GL_BINDING_CALL Mock_glCullFace(GLenum mode) {
  GLInterface::GetGLInterface()->CullFace(mode);
}

void GL_BINDING_CALL Mock_glDeleteBuffersARB(GLsizei n, const GLuint* buffers) {
  GLInterface::GetGLInterface()->DeleteBuffersARB(n, buffers);
}

void GL_BINDING_CALL Mock_glDeleteFramebuffersEXT(GLsizei n, const GLuint* framebuffers) {
  GLInterface::GetGLInterface()->DeleteFramebuffersEXT(n, framebuffers);
}

void GL_BINDING_CALL Mock_glDeleteProgram(GLuint program) {
  GLInterface::GetGLInterface()->DeleteProgram(program);
}

void GL_BINDING_CALL Mock_glDeleteRenderbuffersEXT(GLsizei n, const GLuint* renderbuffers) {
  GLInterface::GetGLInterface()->DeleteRenderbuffersEXT(n, renderbuffers);
}

void GL_BINDING_CALL Mock_glDeleteShader(GLuint shader) {
  GLInterface::GetGLInterface()->DeleteShader(shader);
}

void GL_BINDING_CALL Mock_glDeleteTextures(GLsizei n, const GLuint* textures) {
  GLInterface::GetGLInterface()->DeleteTextures(n, textures);
}

void GL_BINDING_CALL Mock_glDepthFunc(GLenum func) {
  GLInterface::GetGLInterface()->DepthFunc(func);
}

void GL_BINDING_CALL Mock_glDepthMask(GLboolean flag) {
  GLInterface::GetGLInterface()->DepthMask(flag);
}

void GL_BINDING_CALL Mock_glDepthRange(GLclampd zNear, GLclampd zFar) {
  GLInterface::GetGLInterface()->DepthRange(zNear, zFar);
}

void GL_BINDING_CALL Mock_glDepthRangef(GLclampf zNear, GLclampf zFar) {
  GLInterface::GetGLInterface()->DepthRangef(zNear, zFar);
}

void GL_BINDING_CALL Mock_glDetachShader(GLuint program, GLuint shader) {
  GLInterface::GetGLInterface()->DetachShader(program, shader);
}

void GL_BINDING_CALL Mock_glDisable(GLenum cap) {
  GLInterface::GetGLInterface()->Disable(cap);
}

void GL_BINDING_CALL Mock_glDisableVertexAttribArray(GLuint index) {
  GLInterface::GetGLInterface()->DisableVertexAttribArray(index);
}

void GL_BINDING_CALL Mock_glDrawArrays(GLenum mode, GLint first, GLsizei count) {
  GLInterface::GetGLInterface()->DrawArrays(mode, first, count);
}

void GL_BINDING_CALL Mock_glDrawBuffer(GLenum mode) {
  GLInterface::GetGLInterface()->DrawBuffer(mode);
}

void GL_BINDING_CALL Mock_glDrawBuffersARB(GLsizei n, const GLenum* bufs) {
  GLInterface::GetGLInterface()->DrawBuffersARB(n, bufs);
}

void GL_BINDING_CALL Mock_glDrawElements(GLenum mode, GLsizei count, GLenum type, const void* indices) {
  GLInterface::GetGLInterface()->DrawElements(mode, count, type, indices);
}

void GL_BINDING_CALL Mock_glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image) {
  GLInterface::GetGLInterface()->EGLImageTargetTexture2DOES(target, image);
}

void GL_BINDING_CALL Mock_glEnable(GLenum cap) {
  GLInterface::GetGLInterface()->Enable(cap);
}

void GL_BINDING_CALL Mock_glEnableVertexAttribArray(GLuint index) {
  GLInterface::GetGLInterface()->EnableVertexAttribArray(index);
}

void GL_BINDING_CALL Mock_glFinish(void) {
  GLInterface::GetGLInterface()->Finish();
}

void GL_BINDING_CALL Mock_glFlush(void) {
  GLInterface::GetGLInterface()->Flush();
}

void GL_BINDING_CALL Mock_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
  GLInterface::GetGLInterface()->FramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
}

void GL_BINDING_CALL Mock_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
  GLInterface::GetGLInterface()->FramebufferTexture2DEXT(target, attachment, textarget, texture, level);
}

void GL_BINDING_CALL Mock_glFrontFace(GLenum mode) {
  GLInterface::GetGLInterface()->FrontFace(mode);
}

void GL_BINDING_CALL Mock_glGenBuffersARB(GLsizei n, GLuint* buffers) {
  GLInterface::GetGLInterface()->GenBuffersARB(n, buffers);
}

void GL_BINDING_CALL Mock_glGenerateMipmapEXT(GLenum target) {
  GLInterface::GetGLInterface()->GenerateMipmapEXT(target);
}

void GL_BINDING_CALL Mock_glGenFramebuffersEXT(GLsizei n, GLuint* framebuffers) {
  GLInterface::GetGLInterface()->GenFramebuffersEXT(n, framebuffers);
}

void GL_BINDING_CALL Mock_glGenRenderbuffersEXT(GLsizei n, GLuint* renderbuffers) {
  GLInterface::GetGLInterface()->GenRenderbuffersEXT(n, renderbuffers);
}

void GL_BINDING_CALL Mock_glGenTextures(GLsizei n, GLuint* textures) {
  GLInterface::GetGLInterface()->GenTextures(n, textures);
}

void GL_BINDING_CALL Mock_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name) {
  GLInterface::GetGLInterface()->GetActiveAttrib(program, index, bufsize, length, size, type, name);
}

void GL_BINDING_CALL Mock_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name) {
  GLInterface::GetGLInterface()->GetActiveUniform(program, index, bufsize, length, size, type, name);
}

void GL_BINDING_CALL Mock_glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders) {
  GLInterface::GetGLInterface()->GetAttachedShaders(program, maxcount, count, shaders);
}

GLint GL_BINDING_CALL Mock_glGetAttribLocation(GLuint program, const char* name) {
  return GLInterface::GetGLInterface()->GetAttribLocation(program, name);
}

void GL_BINDING_CALL Mock_glGetBooleanv(GLenum pname, GLboolean* params) {
  GLInterface::GetGLInterface()->GetBooleanv(pname, params);
}

void GL_BINDING_CALL Mock_glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetBufferParameteriv(target, pname, params);
}

GLenum GL_BINDING_CALL Mock_glGetError(void) {
  return GLInterface::GetGLInterface()->GetError();
}

void GL_BINDING_CALL Mock_glGetFloatv(GLenum pname, GLfloat* params) {
  GLInterface::GetGLInterface()->GetFloatv(pname, params);
}

void GL_BINDING_CALL Mock_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
}

GLenum GL_BINDING_CALL Mock_glGetGraphicsResetStatusARB(void) {
  return GLInterface::GetGLInterface()->GetGraphicsResetStatusARB();
}

void GL_BINDING_CALL Mock_glGetIntegerv(GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetIntegerv(pname, params);
}

void GL_BINDING_CALL Mock_glGetProgramiv(GLuint program, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetProgramiv(program, pname, params);
}

void GL_BINDING_CALL Mock_glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, char* infolog) {
  GLInterface::GetGLInterface()->GetProgramInfoLog(program, bufsize, length, infolog);
}

void GL_BINDING_CALL Mock_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetRenderbufferParameterivEXT(target, pname, params);
}

void GL_BINDING_CALL Mock_glGetShaderiv(GLuint shader, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetShaderiv(shader, pname, params);
}

void GL_BINDING_CALL Mock_glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog) {
  GLInterface::GetGLInterface()->GetShaderInfoLog(shader, bufsize, length, infolog);
}

void GL_BINDING_CALL Mock_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision) {
  GLInterface::GetGLInterface()->GetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
}

void GL_BINDING_CALL Mock_glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, char* source) {
  GLInterface::GetGLInterface()->GetShaderSource(shader, bufsize, length, source);
}

const GLubyte* GL_BINDING_CALL Mock_glGetString(GLenum name) {
  return GLInterface::GetGLInterface()->GetString(name);
}

void GL_BINDING_CALL Mock_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params) {
  GLInterface::GetGLInterface()->GetTexLevelParameterfv(target, level, pname, params);
}

void GL_BINDING_CALL Mock_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetTexLevelParameteriv(target, level, pname, params);
}

void GL_BINDING_CALL Mock_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params) {
  GLInterface::GetGLInterface()->GetTexParameterfv(target, pname, params);
}

void GL_BINDING_CALL Mock_glGetTexParameteriv(GLenum target, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetTexParameteriv(target, pname, params);
}

void GL_BINDING_CALL Mock_glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei* length, char* source) {
  GLInterface::GetGLInterface()->GetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
}

void GL_BINDING_CALL Mock_glGetUniformfv(GLuint program, GLint location, GLfloat* params) {
  GLInterface::GetGLInterface()->GetUniformfv(program, location, params);
}

void GL_BINDING_CALL Mock_glGetUniformiv(GLuint program, GLint location, GLint* params) {
  GLInterface::GetGLInterface()->GetUniformiv(program, location, params);
}

GLint GL_BINDING_CALL Mock_glGetUniformLocation(GLuint program, const char* name) {
  return GLInterface::GetGLInterface()->GetUniformLocation(program, name);
}

void GL_BINDING_CALL Mock_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params) {
  GLInterface::GetGLInterface()->GetVertexAttribfv(index, pname, params);
}

void GL_BINDING_CALL Mock_glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetVertexAttribiv(index, pname, params);
}

void GL_BINDING_CALL Mock_glGetVertexAttribPointerv(GLuint index, GLenum pname, void** pointer) {
  GLInterface::GetGLInterface()->GetVertexAttribPointerv(index, pname, pointer);
}

void GL_BINDING_CALL Mock_glHint(GLenum target, GLenum mode) {
  GLInterface::GetGLInterface()->Hint(target, mode);
}

GLboolean GL_BINDING_CALL Mock_glIsBuffer(GLuint buffer) {
  return GLInterface::GetGLInterface()->IsBuffer(buffer);
}

GLboolean GL_BINDING_CALL Mock_glIsEnabled(GLenum cap) {
  return GLInterface::GetGLInterface()->IsEnabled(cap);
}

GLboolean GL_BINDING_CALL Mock_glIsFramebufferEXT(GLuint framebuffer) {
  return GLInterface::GetGLInterface()->IsFramebufferEXT(framebuffer);
}

GLboolean GL_BINDING_CALL Mock_glIsProgram(GLuint program) {
  return GLInterface::GetGLInterface()->IsProgram(program);
}

GLboolean GL_BINDING_CALL Mock_glIsRenderbufferEXT(GLuint renderbuffer) {
  return GLInterface::GetGLInterface()->IsRenderbufferEXT(renderbuffer);
}

GLboolean GL_BINDING_CALL Mock_glIsShader(GLuint shader) {
  return GLInterface::GetGLInterface()->IsShader(shader);
}

GLboolean GL_BINDING_CALL Mock_glIsTexture(GLuint texture) {
  return GLInterface::GetGLInterface()->IsTexture(texture);
}

void GL_BINDING_CALL Mock_glLineWidth(GLfloat width) {
  GLInterface::GetGLInterface()->LineWidth(width);
}

void GL_BINDING_CALL Mock_glLinkProgram(GLuint program) {
  GLInterface::GetGLInterface()->LinkProgram(program);
}

void* GL_BINDING_CALL Mock_glMapBuffer(GLenum target, GLenum access) {
  return GLInterface::GetGLInterface()->MapBuffer(target, access);
}

void GL_BINDING_CALL Mock_glPixelStorei(GLenum pname, GLint param) {
  GLInterface::GetGLInterface()->PixelStorei(pname, param);
}

void GL_BINDING_CALL Mock_glPolygonOffset(GLfloat factor, GLfloat units) {
  GLInterface::GetGLInterface()->PolygonOffset(factor, units);
}

void GL_BINDING_CALL Mock_glReadBuffer(GLenum src) {
  GLInterface::GetGLInterface()->ReadBuffer(src);
}

void GL_BINDING_CALL Mock_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels) {
  GLInterface::GetGLInterface()->ReadPixels(x, y, width, height, format, type, pixels);
}

void GL_BINDING_CALL Mock_glReleaseShaderCompiler(void) {
  GLInterface::GetGLInterface()->ReleaseShaderCompiler();
}

void GL_BINDING_CALL Mock_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
  GLInterface::GetGLInterface()->RenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
}

void GL_BINDING_CALL Mock_glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
  GLInterface::GetGLInterface()->RenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
}

void GL_BINDING_CALL Mock_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
  GLInterface::GetGLInterface()->RenderbufferStorageEXT(target, internalformat, width, height);
}

void GL_BINDING_CALL Mock_glSampleCoverage(GLclampf value, GLboolean invert) {
  GLInterface::GetGLInterface()->SampleCoverage(value, invert);
}

void GL_BINDING_CALL Mock_glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
  GLInterface::GetGLInterface()->Scissor(x, y, width, height);
}

void GL_BINDING_CALL Mock_glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length) {
  GLInterface::GetGLInterface()->ShaderBinary(n, shaders, binaryformat, binary, length);
}

void GL_BINDING_CALL Mock_glShaderSource(GLuint shader, GLsizei count, const char** str, const GLint* length) {
  GLInterface::GetGLInterface()->ShaderSource(shader, count, str, length);
}

void GL_BINDING_CALL Mock_glStencilFunc(GLenum func, GLint ref, GLuint mask) {
  GLInterface::GetGLInterface()->StencilFunc(func, ref, mask);
}

void GL_BINDING_CALL Mock_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask) {
  GLInterface::GetGLInterface()->StencilFuncSeparate(face, func, ref, mask);
}

void GL_BINDING_CALL Mock_glStencilMask(GLuint mask) {
  GLInterface::GetGLInterface()->StencilMask(mask);
}

void GL_BINDING_CALL Mock_glStencilMaskSeparate(GLenum face, GLuint mask) {
  GLInterface::GetGLInterface()->StencilMaskSeparate(face, mask);
}

void GL_BINDING_CALL Mock_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
  GLInterface::GetGLInterface()->StencilOp(fail, zfail, zpass);
}

void GL_BINDING_CALL Mock_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass) {
  GLInterface::GetGLInterface()->StencilOpSeparate(face, fail, zfail, zpass);
}

void GL_BINDING_CALL Mock_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels) {
  GLInterface::GetGLInterface()->TexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

void GL_BINDING_CALL Mock_glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
  GLInterface::GetGLInterface()->TexParameterf(target, pname, param);
}

void GL_BINDING_CALL Mock_glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params) {
  GLInterface::GetGLInterface()->TexParameterfv(target, pname, params);
}

void GL_BINDING_CALL Mock_glTexParameteri(GLenum target, GLenum pname, GLint param) {
  GLInterface::GetGLInterface()->TexParameteri(target, pname, param);
}

void GL_BINDING_CALL Mock_glTexParameteriv(GLenum target, GLenum pname, const GLint* params) {
  GLInterface::GetGLInterface()->TexParameteriv(target, pname, params);
}

void GL_BINDING_CALL Mock_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) {
  GLInterface::GetGLInterface()->TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void GL_BINDING_CALL Mock_glUniform1f(GLint location, GLfloat x) {
  GLInterface::GetGLInterface()->Uniform1f(location, x);
}

void GL_BINDING_CALL Mock_glUniform1fv(GLint location, GLsizei count, const GLfloat* v) {
  GLInterface::GetGLInterface()->Uniform1fv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniform1i(GLint location, GLint x) {
  GLInterface::GetGLInterface()->Uniform1i(location, x);
}

void GL_BINDING_CALL Mock_glUniform1iv(GLint location, GLsizei count, const GLint* v) {
  GLInterface::GetGLInterface()->Uniform1iv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniform2f(GLint location, GLfloat x, GLfloat y) {
  GLInterface::GetGLInterface()->Uniform2f(location, x, y);
}

void GL_BINDING_CALL Mock_glUniform2fv(GLint location, GLsizei count, const GLfloat* v) {
  GLInterface::GetGLInterface()->Uniform2fv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniform2i(GLint location, GLint x, GLint y) {
  GLInterface::GetGLInterface()->Uniform2i(location, x, y);
}

void GL_BINDING_CALL Mock_glUniform2iv(GLint location, GLsizei count, const GLint* v) {
  GLInterface::GetGLInterface()->Uniform2iv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z) {
  GLInterface::GetGLInterface()->Uniform3f(location, x, y, z);
}

void GL_BINDING_CALL Mock_glUniform3fv(GLint location, GLsizei count, const GLfloat* v) {
  GLInterface::GetGLInterface()->Uniform3fv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniform3i(GLint location, GLint x, GLint y, GLint z) {
  GLInterface::GetGLInterface()->Uniform3i(location, x, y, z);
}

void GL_BINDING_CALL Mock_glUniform3iv(GLint location, GLsizei count, const GLint* v) {
  GLInterface::GetGLInterface()->Uniform3iv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
  GLInterface::GetGLInterface()->Uniform4f(location, x, y, z, w);
}

void GL_BINDING_CALL Mock_glUniform4fv(GLint location, GLsizei count, const GLfloat* v) {
  GLInterface::GetGLInterface()->Uniform4fv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w) {
  GLInterface::GetGLInterface()->Uniform4i(location, x, y, z, w);
}

void GL_BINDING_CALL Mock_glUniform4iv(GLint location, GLsizei count, const GLint* v) {
  GLInterface::GetGLInterface()->Uniform4iv(location, count, v);
}

void GL_BINDING_CALL Mock_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
  GLInterface::GetGLInterface()->UniformMatrix2fv(location, count, transpose, value);
}

void GL_BINDING_CALL Mock_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
  GLInterface::GetGLInterface()->UniformMatrix3fv(location, count, transpose, value);
}

void GL_BINDING_CALL Mock_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
  GLInterface::GetGLInterface()->UniformMatrix4fv(location, count, transpose, value);
}

GLboolean GL_BINDING_CALL Mock_glUnmapBuffer(GLenum target) {
  return GLInterface::GetGLInterface()->UnmapBuffer(target);
}

void GL_BINDING_CALL Mock_glUseProgram(GLuint program) {
  GLInterface::GetGLInterface()->UseProgram(program);
}

void GL_BINDING_CALL Mock_glValidateProgram(GLuint program) {
  GLInterface::GetGLInterface()->ValidateProgram(program);
}

void GL_BINDING_CALL Mock_glVertexAttrib1f(GLuint indx, GLfloat x) {
  GLInterface::GetGLInterface()->VertexAttrib1f(indx, x);
}

void GL_BINDING_CALL Mock_glVertexAttrib1fv(GLuint indx, const GLfloat* values) {
  GLInterface::GetGLInterface()->VertexAttrib1fv(indx, values);
}

void GL_BINDING_CALL Mock_glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y) {
  GLInterface::GetGLInterface()->VertexAttrib2f(indx, x, y);
}

void GL_BINDING_CALL Mock_glVertexAttrib2fv(GLuint indx, const GLfloat* values) {
  GLInterface::GetGLInterface()->VertexAttrib2fv(indx, values);
}

void GL_BINDING_CALL Mock_glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z) {
  GLInterface::GetGLInterface()->VertexAttrib3f(indx, x, y, z);
}

void GL_BINDING_CALL Mock_glVertexAttrib3fv(GLuint indx, const GLfloat* values) {
  GLInterface::GetGLInterface()->VertexAttrib3fv(indx, values);
}

void GL_BINDING_CALL Mock_glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
  GLInterface::GetGLInterface()->VertexAttrib4f(indx, x, y, z, w);
}

void GL_BINDING_CALL Mock_glVertexAttrib4fv(GLuint indx, const GLfloat* values) {
  GLInterface::GetGLInterface()->VertexAttrib4fv(indx, values);
}

void GL_BINDING_CALL Mock_glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* ptr) {
  GLInterface::GetGLInterface()->VertexAttribPointer(indx, size, type, normalized, stride, ptr);
}

void GL_BINDING_CALL Mock_glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
  GLInterface::GetGLInterface()->Viewport(x, y, width, height);
}

void GL_BINDING_CALL Mock_glGenFencesNV(GLsizei n, GLuint* fences) {
  GLInterface::GetGLInterface()->GenFencesNV(n, fences);
}

void GL_BINDING_CALL Mock_glDeleteFencesNV(GLsizei n, const GLuint* fences) {
  GLInterface::GetGLInterface()->DeleteFencesNV(n, fences);
}

void GL_BINDING_CALL Mock_glSetFenceNV(GLuint fence, GLenum condition) {
  GLInterface::GetGLInterface()->SetFenceNV(fence, condition);
}

GLboolean GL_BINDING_CALL Mock_glTestFenceNV(GLuint fence) {
  return GLInterface::GetGLInterface()->TestFenceNV(fence);
}

void GL_BINDING_CALL Mock_glFinishFenceNV(GLuint fence) {
  GLInterface::GetGLInterface()->FinishFenceNV(fence);
}

GLboolean GL_BINDING_CALL Mock_glIsFenceNV(GLuint fence) {
  return GLInterface::GetGLInterface()->IsFenceNV(fence);
}

void GL_BINDING_CALL Mock_glGetFenceivNV(GLuint fence, GLenum pname, GLint* params) {
  GLInterface::GetGLInterface()->GetFenceivNV(fence, pname, params);
}

void* GL_BINDING_CALL GetMockGLProcAddress(const char* name) {
  if (strcmp(name, "glActiveTexture") == 0)
    return reinterpret_cast<void*>(Mock_glActiveTexture);
  if (strcmp(name, "glAttachShader") == 0)
    return reinterpret_cast<void*>(Mock_glAttachShader);
  if (strcmp(name, "glBindAttribLocation") == 0)
    return reinterpret_cast<void*>(Mock_glBindAttribLocation);
  if (strcmp(name, "glBindBuffer") == 0)
    return reinterpret_cast<void*>(Mock_glBindBuffer);
  if (strcmp(name, "glBindFragDataLocation") == 0)
    return reinterpret_cast<void*>(Mock_glBindFragDataLocation);
  if (strcmp(name, "glBindFragDataLocationIndexedARB") == 0)
    return reinterpret_cast<void*>(Mock_glBindFragDataLocationIndexedARB);
  if (strcmp(name, "glBindFramebufferEXT") == 0)
    return reinterpret_cast<void*>(Mock_glBindFramebufferEXT);
  if (strcmp(name, "glBindRenderbufferEXT") == 0)
    return reinterpret_cast<void*>(Mock_glBindRenderbufferEXT);
  if (strcmp(name, "glBindTexture") == 0)
    return reinterpret_cast<void*>(Mock_glBindTexture);
  if (strcmp(name, "glBlendColor") == 0)
    return reinterpret_cast<void*>(Mock_glBlendColor);
  if (strcmp(name, "glBlendEquation") == 0)
    return reinterpret_cast<void*>(Mock_glBlendEquation);
  if (strcmp(name, "glBlendEquationSeparate") == 0)
    return reinterpret_cast<void*>(Mock_glBlendEquationSeparate);
  if (strcmp(name, "glBlendFunc") == 0)
    return reinterpret_cast<void*>(Mock_glBlendFunc);
  if (strcmp(name, "glBlendFuncSeparate") == 0)
    return reinterpret_cast<void*>(Mock_glBlendFuncSeparate);
  if (strcmp(name, "glBlitFramebufferEXT") == 0)
    return reinterpret_cast<void*>(Mock_glBlitFramebufferEXT);
  if (strcmp(name, "glBlitFramebufferANGLE") == 0)
    return reinterpret_cast<void*>(Mock_glBlitFramebufferANGLE);
  if (strcmp(name, "glBufferData") == 0)
    return reinterpret_cast<void*>(Mock_glBufferData);
  if (strcmp(name, "glBufferSubData") == 0)
    return reinterpret_cast<void*>(Mock_glBufferSubData);
  if (strcmp(name, "glCheckFramebufferStatusEXT") == 0)
    return reinterpret_cast<void*>(Mock_glCheckFramebufferStatusEXT);
  if (strcmp(name, "glClear") == 0)
    return reinterpret_cast<void*>(Mock_glClear);
  if (strcmp(name, "glClearColor") == 0)
    return reinterpret_cast<void*>(Mock_glClearColor);
  if (strcmp(name, "glClearDepth") == 0)
    return reinterpret_cast<void*>(Mock_glClearDepth);
  if (strcmp(name, "glClearDepthf") == 0)
    return reinterpret_cast<void*>(Mock_glClearDepthf);
  if (strcmp(name, "glClearStencil") == 0)
    return reinterpret_cast<void*>(Mock_glClearStencil);
  if (strcmp(name, "glColorMask") == 0)
    return reinterpret_cast<void*>(Mock_glColorMask);
  if (strcmp(name, "glCompileShader") == 0)
    return reinterpret_cast<void*>(Mock_glCompileShader);
  if (strcmp(name, "glCompressedTexImage2D") == 0)
    return reinterpret_cast<void*>(Mock_glCompressedTexImage2D);
  if (strcmp(name, "glCompressedTexSubImage2D") == 0)
    return reinterpret_cast<void*>(Mock_glCompressedTexSubImage2D);
  if (strcmp(name, "glCopyTexImage2D") == 0)
    return reinterpret_cast<void*>(Mock_glCopyTexImage2D);
  if (strcmp(name, "glCopyTexSubImage2D") == 0)
    return reinterpret_cast<void*>(Mock_glCopyTexSubImage2D);
  if (strcmp(name, "glCreateProgram") == 0)
    return reinterpret_cast<void*>(Mock_glCreateProgram);
  if (strcmp(name, "glCreateShader") == 0)
    return reinterpret_cast<void*>(Mock_glCreateShader);
  if (strcmp(name, "glCullFace") == 0)
    return reinterpret_cast<void*>(Mock_glCullFace);
  if (strcmp(name, "glDeleteBuffersARB") == 0)
    return reinterpret_cast<void*>(Mock_glDeleteBuffersARB);
  if (strcmp(name, "glDeleteFramebuffersEXT") == 0)
    return reinterpret_cast<void*>(Mock_glDeleteFramebuffersEXT);
  if (strcmp(name, "glDeleteProgram") == 0)
    return reinterpret_cast<void*>(Mock_glDeleteProgram);
  if (strcmp(name, "glDeleteRenderbuffersEXT") == 0)
    return reinterpret_cast<void*>(Mock_glDeleteRenderbuffersEXT);
  if (strcmp(name, "glDeleteShader") == 0)
    return reinterpret_cast<void*>(Mock_glDeleteShader);
  if (strcmp(name, "glDeleteTextures") == 0)
    return reinterpret_cast<void*>(Mock_glDeleteTextures);
  if (strcmp(name, "glDepthFunc") == 0)
    return reinterpret_cast<void*>(Mock_glDepthFunc);
  if (strcmp(name, "glDepthMask") == 0)
    return reinterpret_cast<void*>(Mock_glDepthMask);
  if (strcmp(name, "glDepthRange") == 0)
    return reinterpret_cast<void*>(Mock_glDepthRange);
  if (strcmp(name, "glDepthRangef") == 0)
    return reinterpret_cast<void*>(Mock_glDepthRangef);
  if (strcmp(name, "glDetachShader") == 0)
    return reinterpret_cast<void*>(Mock_glDetachShader);
  if (strcmp(name, "glDisable") == 0)
    return reinterpret_cast<void*>(Mock_glDisable);
  if (strcmp(name, "glDisableVertexAttribArray") == 0)
    return reinterpret_cast<void*>(Mock_glDisableVertexAttribArray);
  if (strcmp(name, "glDrawArrays") == 0)
    return reinterpret_cast<void*>(Mock_glDrawArrays);
  if (strcmp(name, "glDrawBuffer") == 0)
    return reinterpret_cast<void*>(Mock_glDrawBuffer);
  if (strcmp(name, "glDrawBuffersARB") == 0)
    return reinterpret_cast<void*>(Mock_glDrawBuffersARB);
  if (strcmp(name, "glDrawElements") == 0)
    return reinterpret_cast<void*>(Mock_glDrawElements);
  if (strcmp(name, "glEGLImageTargetTexture2DOES") == 0)
    return reinterpret_cast<void*>(Mock_glEGLImageTargetTexture2DOES);
  if (strcmp(name, "glEnable") == 0)
    return reinterpret_cast<void*>(Mock_glEnable);
  if (strcmp(name, "glEnableVertexAttribArray") == 0)
    return reinterpret_cast<void*>(Mock_glEnableVertexAttribArray);
  if (strcmp(name, "glFinish") == 0)
    return reinterpret_cast<void*>(Mock_glFinish);
  if (strcmp(name, "glFlush") == 0)
    return reinterpret_cast<void*>(Mock_glFlush);
  if (strcmp(name, "glFramebufferRenderbufferEXT") == 0)
    return reinterpret_cast<void*>(Mock_glFramebufferRenderbufferEXT);
  if (strcmp(name, "glFramebufferTexture2DEXT") == 0)
    return reinterpret_cast<void*>(Mock_glFramebufferTexture2DEXT);
  if (strcmp(name, "glFrontFace") == 0)
    return reinterpret_cast<void*>(Mock_glFrontFace);
  if (strcmp(name, "glGenBuffersARB") == 0)
    return reinterpret_cast<void*>(Mock_glGenBuffersARB);
  if (strcmp(name, "glGenerateMipmapEXT") == 0)
    return reinterpret_cast<void*>(Mock_glGenerateMipmapEXT);
  if (strcmp(name, "glGenFramebuffersEXT") == 0)
    return reinterpret_cast<void*>(Mock_glGenFramebuffersEXT);
  if (strcmp(name, "glGenRenderbuffersEXT") == 0)
    return reinterpret_cast<void*>(Mock_glGenRenderbuffersEXT);
  if (strcmp(name, "glGenTextures") == 0)
    return reinterpret_cast<void*>(Mock_glGenTextures);
  if (strcmp(name, "glGetActiveAttrib") == 0)
    return reinterpret_cast<void*>(Mock_glGetActiveAttrib);
  if (strcmp(name, "glGetActiveUniform") == 0)
    return reinterpret_cast<void*>(Mock_glGetActiveUniform);
  if (strcmp(name, "glGetAttachedShaders") == 0)
    return reinterpret_cast<void*>(Mock_glGetAttachedShaders);
  if (strcmp(name, "glGetAttribLocation") == 0)
    return reinterpret_cast<void*>(Mock_glGetAttribLocation);
  if (strcmp(name, "glGetBooleanv") == 0)
    return reinterpret_cast<void*>(Mock_glGetBooleanv);
  if (strcmp(name, "glGetBufferParameteriv") == 0)
    return reinterpret_cast<void*>(Mock_glGetBufferParameteriv);
  if (strcmp(name, "glGetError") == 0)
    return reinterpret_cast<void*>(Mock_glGetError);
  if (strcmp(name, "glGetFloatv") == 0)
    return reinterpret_cast<void*>(Mock_glGetFloatv);
  if (strcmp(name, "glGetFramebufferAttachmentParameterivEXT") == 0)
    return reinterpret_cast<void*>(Mock_glGetFramebufferAttachmentParameterivEXT);
  if (strcmp(name, "glGetGraphicsResetStatusARB") == 0)
    return reinterpret_cast<void*>(Mock_glGetGraphicsResetStatusARB);
  if (strcmp(name, "glGetIntegerv") == 0)
    return reinterpret_cast<void*>(Mock_glGetIntegerv);
  if (strcmp(name, "glGetProgramiv") == 0)
    return reinterpret_cast<void*>(Mock_glGetProgramiv);
  if (strcmp(name, "glGetProgramInfoLog") == 0)
    return reinterpret_cast<void*>(Mock_glGetProgramInfoLog);
  if (strcmp(name, "glGetRenderbufferParameterivEXT") == 0)
    return reinterpret_cast<void*>(Mock_glGetRenderbufferParameterivEXT);
  if (strcmp(name, "glGetShaderiv") == 0)
    return reinterpret_cast<void*>(Mock_glGetShaderiv);
  if (strcmp(name, "glGetShaderInfoLog") == 0)
    return reinterpret_cast<void*>(Mock_glGetShaderInfoLog);
  if (strcmp(name, "glGetShaderPrecisionFormat") == 0)
    return reinterpret_cast<void*>(Mock_glGetShaderPrecisionFormat);
  if (strcmp(name, "glGetShaderSource") == 0)
    return reinterpret_cast<void*>(Mock_glGetShaderSource);
  if (strcmp(name, "glGetString") == 0)
    return reinterpret_cast<void*>(Mock_glGetString);
  if (strcmp(name, "glGetTexLevelParameterfv") == 0)
    return reinterpret_cast<void*>(Mock_glGetTexLevelParameterfv);
  if (strcmp(name, "glGetTexLevelParameteriv") == 0)
    return reinterpret_cast<void*>(Mock_glGetTexLevelParameteriv);
  if (strcmp(name, "glGetTexParameterfv") == 0)
    return reinterpret_cast<void*>(Mock_glGetTexParameterfv);
  if (strcmp(name, "glGetTexParameteriv") == 0)
    return reinterpret_cast<void*>(Mock_glGetTexParameteriv);
  if (strcmp(name, "glGetTranslatedShaderSourceANGLE") == 0)
    return reinterpret_cast<void*>(Mock_glGetTranslatedShaderSourceANGLE);
  if (strcmp(name, "glGetUniformfv") == 0)
    return reinterpret_cast<void*>(Mock_glGetUniformfv);
  if (strcmp(name, "glGetUniformiv") == 0)
    return reinterpret_cast<void*>(Mock_glGetUniformiv);
  if (strcmp(name, "glGetUniformLocation") == 0)
    return reinterpret_cast<void*>(Mock_glGetUniformLocation);
  if (strcmp(name, "glGetVertexAttribfv") == 0)
    return reinterpret_cast<void*>(Mock_glGetVertexAttribfv);
  if (strcmp(name, "glGetVertexAttribiv") == 0)
    return reinterpret_cast<void*>(Mock_glGetVertexAttribiv);
  if (strcmp(name, "glGetVertexAttribPointerv") == 0)
    return reinterpret_cast<void*>(Mock_glGetVertexAttribPointerv);
  if (strcmp(name, "glHint") == 0)
    return reinterpret_cast<void*>(Mock_glHint);
  if (strcmp(name, "glIsBuffer") == 0)
    return reinterpret_cast<void*>(Mock_glIsBuffer);
  if (strcmp(name, "glIsEnabled") == 0)
    return reinterpret_cast<void*>(Mock_glIsEnabled);
  if (strcmp(name, "glIsFramebufferEXT") == 0)
    return reinterpret_cast<void*>(Mock_glIsFramebufferEXT);
  if (strcmp(name, "glIsProgram") == 0)
    return reinterpret_cast<void*>(Mock_glIsProgram);
  if (strcmp(name, "glIsRenderbufferEXT") == 0)
    return reinterpret_cast<void*>(Mock_glIsRenderbufferEXT);
  if (strcmp(name, "glIsShader") == 0)
    return reinterpret_cast<void*>(Mock_glIsShader);
  if (strcmp(name, "glIsTexture") == 0)
    return reinterpret_cast<void*>(Mock_glIsTexture);
  if (strcmp(name, "glLineWidth") == 0)
    return reinterpret_cast<void*>(Mock_glLineWidth);
  if (strcmp(name, "glLinkProgram") == 0)
    return reinterpret_cast<void*>(Mock_glLinkProgram);
  if (strcmp(name, "glMapBuffer") == 0)
    return reinterpret_cast<void*>(Mock_glMapBuffer);
  if (strcmp(name, "glPixelStorei") == 0)
    return reinterpret_cast<void*>(Mock_glPixelStorei);
  if (strcmp(name, "glPolygonOffset") == 0)
    return reinterpret_cast<void*>(Mock_glPolygonOffset);
  if (strcmp(name, "glReadBuffer") == 0)
    return reinterpret_cast<void*>(Mock_glReadBuffer);
  if (strcmp(name, "glReadPixels") == 0)
    return reinterpret_cast<void*>(Mock_glReadPixels);
  if (strcmp(name, "glReleaseShaderCompiler") == 0)
    return reinterpret_cast<void*>(Mock_glReleaseShaderCompiler);
  if (strcmp(name, "glRenderbufferStorageMultisampleEXT") == 0)
    return reinterpret_cast<void*>(Mock_glRenderbufferStorageMultisampleEXT);
  if (strcmp(name, "glRenderbufferStorageMultisampleANGLE") == 0)
    return reinterpret_cast<void*>(Mock_glRenderbufferStorageMultisampleANGLE);
  if (strcmp(name, "glRenderbufferStorageEXT") == 0)
    return reinterpret_cast<void*>(Mock_glRenderbufferStorageEXT);
  if (strcmp(name, "glSampleCoverage") == 0)
    return reinterpret_cast<void*>(Mock_glSampleCoverage);
  if (strcmp(name, "glScissor") == 0)
    return reinterpret_cast<void*>(Mock_glScissor);
  if (strcmp(name, "glShaderBinary") == 0)
    return reinterpret_cast<void*>(Mock_glShaderBinary);
  if (strcmp(name, "glShaderSource") == 0)
    return reinterpret_cast<void*>(Mock_glShaderSource);
  if (strcmp(name, "glStencilFunc") == 0)
    return reinterpret_cast<void*>(Mock_glStencilFunc);
  if (strcmp(name, "glStencilFuncSeparate") == 0)
    return reinterpret_cast<void*>(Mock_glStencilFuncSeparate);
  if (strcmp(name, "glStencilMask") == 0)
    return reinterpret_cast<void*>(Mock_glStencilMask);
  if (strcmp(name, "glStencilMaskSeparate") == 0)
    return reinterpret_cast<void*>(Mock_glStencilMaskSeparate);
  if (strcmp(name, "glStencilOp") == 0)
    return reinterpret_cast<void*>(Mock_glStencilOp);
  if (strcmp(name, "glStencilOpSeparate") == 0)
    return reinterpret_cast<void*>(Mock_glStencilOpSeparate);
  if (strcmp(name, "glTexImage2D") == 0)
    return reinterpret_cast<void*>(Mock_glTexImage2D);
  if (strcmp(name, "glTexParameterf") == 0)
    return reinterpret_cast<void*>(Mock_glTexParameterf);
  if (strcmp(name, "glTexParameterfv") == 0)
    return reinterpret_cast<void*>(Mock_glTexParameterfv);
  if (strcmp(name, "glTexParameteri") == 0)
    return reinterpret_cast<void*>(Mock_glTexParameteri);
  if (strcmp(name, "glTexParameteriv") == 0)
    return reinterpret_cast<void*>(Mock_glTexParameteriv);
  if (strcmp(name, "glTexSubImage2D") == 0)
    return reinterpret_cast<void*>(Mock_glTexSubImage2D);
  if (strcmp(name, "glUniform1f") == 0)
    return reinterpret_cast<void*>(Mock_glUniform1f);
  if (strcmp(name, "glUniform1fv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform1fv);
  if (strcmp(name, "glUniform1i") == 0)
    return reinterpret_cast<void*>(Mock_glUniform1i);
  if (strcmp(name, "glUniform1iv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform1iv);
  if (strcmp(name, "glUniform2f") == 0)
    return reinterpret_cast<void*>(Mock_glUniform2f);
  if (strcmp(name, "glUniform2fv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform2fv);
  if (strcmp(name, "glUniform2i") == 0)
    return reinterpret_cast<void*>(Mock_glUniform2i);
  if (strcmp(name, "glUniform2iv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform2iv);
  if (strcmp(name, "glUniform3f") == 0)
    return reinterpret_cast<void*>(Mock_glUniform3f);
  if (strcmp(name, "glUniform3fv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform3fv);
  if (strcmp(name, "glUniform3i") == 0)
    return reinterpret_cast<void*>(Mock_glUniform3i);
  if (strcmp(name, "glUniform3iv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform3iv);
  if (strcmp(name, "glUniform4f") == 0)
    return reinterpret_cast<void*>(Mock_glUniform4f);
  if (strcmp(name, "glUniform4fv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform4fv);
  if (strcmp(name, "glUniform4i") == 0)
    return reinterpret_cast<void*>(Mock_glUniform4i);
  if (strcmp(name, "glUniform4iv") == 0)
    return reinterpret_cast<void*>(Mock_glUniform4iv);
  if (strcmp(name, "glUniformMatrix2fv") == 0)
    return reinterpret_cast<void*>(Mock_glUniformMatrix2fv);
  if (strcmp(name, "glUniformMatrix3fv") == 0)
    return reinterpret_cast<void*>(Mock_glUniformMatrix3fv);
  if (strcmp(name, "glUniformMatrix4fv") == 0)
    return reinterpret_cast<void*>(Mock_glUniformMatrix4fv);
  if (strcmp(name, "glUnmapBuffer") == 0)
    return reinterpret_cast<void*>(Mock_glUnmapBuffer);
  if (strcmp(name, "glUseProgram") == 0)
    return reinterpret_cast<void*>(Mock_glUseProgram);
  if (strcmp(name, "glValidateProgram") == 0)
    return reinterpret_cast<void*>(Mock_glValidateProgram);
  if (strcmp(name, "glVertexAttrib1f") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib1f);
  if (strcmp(name, "glVertexAttrib1fv") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib1fv);
  if (strcmp(name, "glVertexAttrib2f") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib2f);
  if (strcmp(name, "glVertexAttrib2fv") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib2fv);
  if (strcmp(name, "glVertexAttrib3f") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib3f);
  if (strcmp(name, "glVertexAttrib3fv") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib3fv);
  if (strcmp(name, "glVertexAttrib4f") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib4f);
  if (strcmp(name, "glVertexAttrib4fv") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttrib4fv);
  if (strcmp(name, "glVertexAttribPointer") == 0)
    return reinterpret_cast<void*>(Mock_glVertexAttribPointer);
  if (strcmp(name, "glViewport") == 0)
    return reinterpret_cast<void*>(Mock_glViewport);
  if (strcmp(name, "glGenFencesNV") == 0)
    return reinterpret_cast<void*>(Mock_glGenFencesNV);
  if (strcmp(name, "glDeleteFencesNV") == 0)
    return reinterpret_cast<void*>(Mock_glDeleteFencesNV);
  if (strcmp(name, "glSetFenceNV") == 0)
    return reinterpret_cast<void*>(Mock_glSetFenceNV);
  if (strcmp(name, "glTestFenceNV") == 0)
    return reinterpret_cast<void*>(Mock_glTestFenceNV);
  if (strcmp(name, "glFinishFenceNV") == 0)
    return reinterpret_cast<void*>(Mock_glFinishFenceNV);
  if (strcmp(name, "glIsFenceNV") == 0)
    return reinterpret_cast<void*>(Mock_glIsFenceNV);
  if (strcmp(name, "glGetFenceivNV") == 0)
    return reinterpret_cast<void*>(Mock_glGetFenceivNV);
  return NULL;
}

}  // namespace gfx
